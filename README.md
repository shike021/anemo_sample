# Anemo 聊天程序示例

这是一个基于 Anemo 网络库的聊天程序示例，展示了如何使用 Rust 构建分布式聊天应用，并保持业务逻辑与网络层的良好分离。

## 项目架构

### 核心模块

1. **消息层 (`message.rs`)**
   - 定义聊天消息的数据结构
   - 处理消息的序列化和反序列化
   - 提供消息格式化和时间戳功能

2. **业务逻辑层 (`chat_service.rs`)**
   - 管理聊天室状态和用户信息
   - 处理消息路由和广播逻辑
   - 维护消息历史记录

3. **网络服务层 (`network_service.rs`)**
   - 适配器模式，连接业务逻辑层和网络层
   - 处理 RPC 请求和响应
   - 管理网络事件

4. **简化实现 (`simple_chat.rs`)**
   - 提供基本的网络连接功能
   - 简化的聊天界面
   - 适合学习和演示

## 设计原则

### 分层架构
```
┌─────────────────────┐
│    用户界面层        │
├─────────────────────┤
│    业务逻辑层        │
├─────────────────────┤
│    网络服务层        │
├─────────────────────┤
│    Anemo 网络层     │
└─────────────────────┘
```

### 业务逻辑与网络分离
- 聊天服务 (`ChatService`) 专注于业务逻辑，不依赖具体的网络实现
- 网络服务 (`ChatNetworkService`) 作为适配器，处理网络通信细节
- 消息结构独立定义，可以轻松切换序列化方式

## 功能特性

### 已实现功能
- ✅ 基本的网络连接和断开
- ✅ 用户加入和离开聊天室
- ✅ 文本消息发送和接收
- ✅ 消息历史记录
- ✅ 用户状态管理
- ✅ 简化的聊天界面

### 计划功能
- 🔄 消息广播到所有用户
- 🔄 完整的 RPC 服务实现
- 🔄 网络事件监听
- 🔄 消息持久化
- 🔄 用户身份验证

## 使用方法

### 启动简化版服务器
```bash
cargo run
```

### 启动简化版客户端
```bash
cargo run -- client [用户名]
```

示例：
```bash
# 终端1：启动服务器
cargo run

# 终端2：启动客户端（用户Alice）
cargo run -- client Alice

# 终端3：启动客户端（用户Bob）
cargo run -- client Bob
```

### 启动高级版本（实验性）
```bash
# 高级服务器
cargo run -- advanced

# 高级客户端
cargo run -- advanced client [用户名]
```

## 客户端操作

启动客户端后，你可以：

1. **发送消息**：直接输入文本并按回车
2. **退出聊天**：输入 `quit` 或 `exit`
3. **查看状态**：程序会显示连接状态和用户信息

示例聊天会话：
```
=== 简化聊天室 ===
用户名: Alice
连接状态: 已连接
输入消息后按回车发送，输入 'quit' 退出
注意: 这是一个简化版本，消息不会实际发送到其他用户
================
[Alice] > 你好大家！
✓ [Alice]: 你好大家！
[Alice] > 这是一个测试消息
✓ [Alice]: 这是一个测试消息
[Alice] > quit
```

## 项目结构

```
anemo-example/
├── src/
│   ├── main.rs              # 主程序入口
│   ├── message.rs           # 消息数据结构
│   ├── chat_service.rs      # 聊天业务逻辑
│   ├── network_service.rs   # 网络服务适配器
│   ├── simple_chat.rs       # 简化实现
│   └── client.rs            # 客户端实现
├── docs/                    # 文档目录
├── Cargo.toml              # 项目配置
└── README.md               # 本文件
```

## 技术细节

### Anemo 网络库
- 基于 QUIC 协议的现代网络库
- 内置 TLS 加密
- 支持多路复用和低延迟通信
- 适合构建分布式系统

### 消息序列化
- 使用 serde 进行 JSON 序列化
- 支持多种消息类型：文本、用户加入/离开、心跳
- 自动时间戳和消息格式化

### 异步编程
- 全异步设计，基于 tokio 运行时
- 非阻塞 I/O 和并发处理
- 超时控制和错误处理

## 故障排除

### 常见问题

1. **连接失败**
   - 检查服务器是否已启动
   - 确认端口 8080 未被占用
   - 查看防火墙设置

2. **编译错误**
   - 确保 Rust 版本兼容（建议 1.70+）
   - 检查依赖项是否正确安装
   - 清理构建缓存：`cargo clean`

3. **RPC 相关错误**
   - 高级版本可能存在兼容性问题
   - 建议使用简化版本进行学习

### 调试建议

1. **启用详细日志**
   ```bash
   RUST_LOG=debug cargo run
   ```

2. **检查网络状态**
   - 使用 `netstat -an | grep 8080` 检查端口
   - 使用 `telnet 127.0.0.1 8080` 测试连接

## 扩展开发

### 添加新功能
1. 在 `message.rs` 中定义新的消息类型
2. 在 `chat_service.rs` 中实现业务逻辑
3. 在 `network_service.rs` 中添加网络处理
4. 更新客户端界面

### 自定义网络协议
1. 修改 `ChatRequest` 和 `ChatResponse` 结构
2. 实现自定义序列化方式
3. 添加加密和压缩支持

## 贡献指南

欢迎提交 Pull Request 和 Issue！

### 开发环境
```bash
# 克隆项目
git clone <repository-url>
cd anemo-example

# 安装依赖
cargo build

# 运行测试
cargo test

# 运行示例
cargo run
```

## 许可证

本项目采用 MIT 许可证。

## 相关资源

- [Anemo GitHub](https://github.com/mystenlabs/anemo)
- [Tokio 文档](https://tokio.rs/)
- [Serde 序列化](https://serde.rs/)
- [Rust 异步编程](https://rust-lang.github.io/async-book/)

---

**注意**：这是一个学习示例项目，不建议直接在生产环境中使用。如需生产级别的聊天应用，请考虑添加安全验证、消息持久化、负载均衡等功能。 